---
phase: 03-stock-suggestions
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - Fusion-360-MCP-Server/stock_suggestions/cylindrical_detector.py
  - Fusion-360-MCP-Server/stock_suggestions/preference_store.py
  - Fusion-360-MCP-Server/stock_suggestions/__init__.py
autonomous: true

must_haves:
  truths:
    - "Cylindrical parts are detected with confidence score and reasoning"
    - "Both round and rectangular stock options shown for cylindrical parts"
    - "Preferences are stored and retrieved by material + geometry_type key"
    - "SQLite schema is initialized before first preference operation"
  artifacts:
    - path: "Fusion-360-MCP-Server/stock_suggestions/cylindrical_detector.py"
      provides: "Cylindrical part detection with enclosing diameter"
      exports: ["detect_cylindrical_part"]
    - path: "Fusion-360-MCP-Server/stock_suggestions/preference_store.py"
      provides: "SQLite preference storage via MCP bridge"
      exports: ["get_preference", "save_preference", "initialize_schema"]
  key_links:
    - from: "preference_store.py"
      to: "mcp.call('sqlite')"
      via: "MCP bridge SQLite calls"
      pattern: "mcp\\.call.*sqlite"
---

<objective>
Create cylindrical part detection and SQLite preference storage.

Purpose: Detect when parts are suitable for round stock (with trade-off options per CONTEXT.md), and provide preference storage/retrieval keyed by material + geometry type with source attribution.

Output:
- `cylindrical_detector.py` - Detects lathe candidates with confidence and enclosing diameter
- `preference_store.py` - SQLite operations via MCP bridge with schema initialization
</objective>

<execution_context>
@C:\Users\cdeit\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cdeit\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-stock-suggestions/03-CONTEXT.md
@.planning/phases/03-stock-suggestions/03-RESEARCH.md
@Fusion-360-MCP-Server/lib/mcp_bridge.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create cylindrical part detector</name>
  <files>
    Fusion-360-MCP-Server/stock_suggestions/cylindrical_detector.py
  </files>
  <action>
Create cylindrical_detector.py with part shape analysis:

1. Create `detect_cylindrical_part(body, features=None)` function:
   - body: BRepBody to analyze
   - features: Optional list of detected features from Phase 2 (not used in v1, reserved for enhancement)

2. Detection heuristics:
   a. Get bounding box dimensions (convert cm to mm)
   b. Sort dimensions to find min1, min2, max
   c. Check elongated aspect ratio: if min1 ~ min2 (within 20-25%) and both << max, likely elongated cylinder
   d. Check disc aspect: if max1 ~ max2 and both >> min, likely disc/flange
   e. Count cylindrical faces vs total faces (adsk.core.Cylinder geometry)
   f. Combine scores: face_ratio * 0.6 + elongated_score * 0.4

3. Calculate enclosing diameter:
   - Diagonal of smaller cross-section: sqrt(min1^2 + min2^2)
   - This is the minimum round stock diameter needed

4. Determine likely axis:
   - Elongated: axis along longest dimension
   - Disc: axis along shortest dimension

5. Return structure:
   ```python
   {
       "is_cylindrical": bool,           # True if likely lathe candidate
       "confidence": float,              # 0.0-1.0
       "reasoning": str,                 # Human-readable explanation
       "cylinder_axis": str or None,     # "X", "Y", or "Z" if cylindrical
       "enclosing_diameter_mm": float,   # Min round stock diameter needed
       "trade_offs": {                   # Per CONTEXT.md: show both options
           "rectangular": "More stable fixturing, easier to clamp",
           "round": "Less material waste, faster for cylindrical parts"
       } if is_cylindrical else None
   }
   ```

6. Include Fusion API imports with try/except pattern (FUSION_AVAILABLE flag)
  </action>
  <verify>
    - File exists: Fusion-360-MCP-Server/stock_suggestions/cylindrical_detector.py
    - Python syntax valid: python -c "from stock_suggestions.cylindrical_detector import detect_cylindrical_part"
    - Function signature correct with body and optional features parameters
  </verify>
  <done>
    - detect_cylindrical_part analyzes bounding box and face geometry
    - Returns confidence score with reasoning
    - Calculates enclosing diameter for round stock sizing
    - Includes trade_offs dict for cylindrical parts per CONTEXT.md
  </done>
</task>

<task type="auto">
  <name>Task 2: Create preference store with SQLite schema</name>
  <files>
    Fusion-360-MCP-Server/stock_suggestions/preference_store.py
    Fusion-360-MCP-Server/stock_suggestions/__init__.py
  </files>
  <action>
Create preference_store.py with SQLite operations via MCP bridge:

1. Define schema constants:
   ```python
   STOCK_PREFERENCES_SCHEMA = """
   CREATE TABLE IF NOT EXISTS cam_stock_preferences (
       id INTEGER PRIMARY KEY AUTOINCREMENT,
       material TEXT NOT NULL,
       geometry_type TEXT NOT NULL,
       offsets_xy_mm REAL DEFAULT 5.0,
       offsets_z_mm REAL DEFAULT 2.5,
       preferred_orientation TEXT,
       stock_shape TEXT DEFAULT 'rectangular',
       machining_allowance_mm REAL,
       created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
       updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
       UNIQUE(material, geometry_type)
   );
   """

   MACHINE_PROFILES_SCHEMA = """
   CREATE TABLE IF NOT EXISTS cam_machine_profiles (
       id INTEGER PRIMARY KEY AUTOINCREMENT,
       name TEXT NOT NULL UNIQUE,
       machine_type TEXT NOT NULL,
       max_x_mm REAL,
       max_y_mm REAL,
       max_z_mm REAL,
       spindle_max_rpm INTEGER,
       has_4th_axis INTEGER DEFAULT 0,
       has_5th_axis INTEGER DEFAULT 0,
       post_processor TEXT,
       created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
   );
   """
   ```

2. Create `initialize_schema(mcp_call_func)`:
   - Takes the mcp.call function (or equivalent callable)
   - Executes both CREATE TABLE statements
   - Uses tool_unlock_token "29e63eb5" per mcp_bridge.py docs
   - Returns True on success, False on error
   - Safe to call multiple times (IF NOT EXISTS)

3. Create `get_preference(material, geometry_type, mcp_call_func)`:
   - Normalize material and geometry_type to lowercase
   - Query cam_stock_preferences with material + geometry_type
   - Return dict with offsets, preferred_orientation, stock_shape, source="from: user_preference"
   - Return None if no matching preference found

4. Create `save_preference(material, geometry_type, preference_dict, mcp_call_func)`:
   - Normalize material and geometry_type to lowercase
   - Use INSERT OR REPLACE to upsert preference
   - preference_dict contains: offsets, preferred_orientation, stock_shape, machining_allowance_mm
   - Return True on success, False on error

5. Create `classify_geometry_type(features)`:
   - Takes list of features from analyze_geometry_for_cam
   - Count holes vs pockets/slots
   - Return: "pocket-heavy" (>70% pockets), "hole-heavy" (>70% holes), "mixed", "simple" (<3 features)

6. Update __init__.py to export:
   - detect_cylindrical_part
   - get_preference, save_preference, initialize_schema
   - classify_geometry_type
   - STOCK_PREFERENCES_SCHEMA, MACHINE_PROFILES_SCHEMA
  </action>
  <verify>
    - File exists: Fusion-360-MCP-Server/stock_suggestions/preference_store.py
    - Python syntax valid: python -c "from stock_suggestions.preference_store import get_preference, save_preference, initialize_schema"
    - Schema strings contain CREATE TABLE statements
    - classify_geometry_type handles empty features list
  </verify>
  <done>
    - SQLite schema defined for cam_stock_preferences and cam_machine_profiles
    - initialize_schema creates tables via MCP bridge
    - get_preference returns preference with "from: user_preference" source
    - save_preference stores with material + geometry_type key (lowercase normalized)
    - classify_geometry_type categorizes by dominant feature type
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. Import test: `python -c "from stock_suggestions import detect_cylindrical_part, get_preference, save_preference, initialize_schema, classify_geometry_type; print('OK')"`
2. Verify classify_geometry_type([]) returns "simple"
3. Verify schema contains "material TEXT NOT NULL" and "geometry_type TEXT NOT NULL"
4. Verify trade_offs included in cylindrical detection for cylindrical parts
</verification>

<success_criteria>
- Cylindrical detection returns confidence score and enclosing diameter
- Trade-offs shown for cylindrical parts (rectangular vs round options)
- Preference keyed by material + geometry_type per CONTEXT.md
- Source attribution "from: user_preference" in get_preference return
- Schema initialization safe to call multiple times
</success_criteria>

<output>
After completion, create `.planning/phases/03-stock-suggestions/03-02-SUMMARY.md`
</output>
