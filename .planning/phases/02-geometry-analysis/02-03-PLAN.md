---
phase: 02-geometry-analysis
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - Fusion-360-MCP-Server/geometry_analysis/orientation_analyzer.py
  - Fusion-360-MCP-Server/geometry_analysis/geometry_helpers.py
  - Fusion-360-MCP-Server/geometry_analysis/__init__.py
  - Fusion-360-MCP-Server/cam_operations.py
autonomous: true

must_haves:
  truths:
    - "Orientations ranked by setup count (minimize flips)"
    - "Each orientation includes setup/op sequence"
    - "Unreachable features flagged with reason"
    - "Global minimum tool radius calculated"
    - "Per-feature minimum tool radius where applicable"
  artifacts:
    - path: "Fusion-360-MCP-Server/geometry_analysis/orientation_analyzer.py"
      provides: "OrientationAnalyzer class with suggest_orientations method"
      min_lines: 80
    - path: "Fusion-360-MCP-Server/geometry_analysis/geometry_helpers.py"
      provides: "Helper functions for radius and accessibility analysis"
      exports: ["calculate_minimum_tool_radii", "analyze_feature_accessibility"]
    - path: "Fusion-360-MCP-Server/cam_operations.py"
      provides: "Enhanced orientation suggestions with sequences"
      contains: "setup_sequence"
  key_links:
    - from: "cam_operations.py"
      to: "orientation_analyzer.py"
      via: "import and method call"
      pattern: "OrientationAnalyzer|suggest_orientations"
    - from: "cam_operations.py"
      to: "geometry_helpers.py"
      via: "import and function call"
      pattern: "calculate_minimum_tool_radii"
---

<objective>
Implement orientation analysis with setup sequences, unreachable feature detection, and minimum tool radius calculations.

Purpose: Help users plan workholding and setup sequences before opening CAM workspace. Identify features that require special tooling or 4th axis. Provide actionable tool radius requirements.

Output: `orientation_analyzer.py` with ranked orientation suggestions including setup sequences, `geometry_helpers.py` with tool radius calculations, integrated into `cam_operations.py`.
</objective>

<execution_context>
@C:\Users\cdeit\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cdeit\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-geometry-analysis/02-CONTEXT.md
@.planning/phases/02-geometry-analysis/02-RESEARCH.md

# Prior plan output
@.planning/phases/02-geometry-analysis/02-01-SUMMARY.md

# Current implementation
@Fusion-360-MCP-Server/geometry_analysis/feature_detector.py
@Fusion-360-MCP-Server/cam_operations.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create geometry helpers with tool radius calculation</name>
  <files>Fusion-360-MCP-Server/geometry_analysis/geometry_helpers.py</files>
  <action>
Create `geometry_helpers.py` with:

**`_to_mm_unit(cm_value) -> dict`**: Returns `{"value": round(cm_value * 10, 3), "unit": "mm"}`

**`calculate_minimum_tool_radii(body, features) -> dict`**:
Per RESEARCH.md Pattern 6:
```python
def calculate_minimum_tool_radii(body, features):
    """
    Calculate minimum tool radius requirements.

    Args:
        body: BRepBody to analyze
        features: List of detected features (for per-feature radii)

    Returns:
        {
            "global_minimum_radius": {"value": X, "unit": "mm"} or None,
            "recommended_tool_radius": {"value": X, "unit": "mm"} or None,
            "design_guideline": str
        }
    """
    import adsk.core

    global_min_radius = float('inf')

    # Scan all faces for smallest concave radius
    for face in body.faces:
        geom = face.geometry

        # Check toroidal faces (fillets, rounds)
        if isinstance(geom, adsk.core.Torus):
            minor_radius_mm = geom.minorRadius * 10  # cm to mm
            if minor_radius_mm < global_min_radius:
                global_min_radius = minor_radius_mm

        # Check edges for small arcs
        for edge in face.edges:
            edge_geom = edge.geometry
            if isinstance(edge_geom, (adsk.core.Circle, adsk.core.Arc3D)):
                radius_mm = edge_geom.radius * 10
                if radius_mm < global_min_radius:
                    global_min_radius = radius_mm

    # Apply 80% rule: recommended tool radius is 80% of minimum corner
    if global_min_radius != float('inf'):
        recommended = global_min_radius * 0.8
        return {
            "global_minimum_radius": _to_mm_unit(global_min_radius / 10),
            "recommended_tool_radius": _to_mm_unit(recommended / 10),
            "design_guideline": "Tool radius should be <= 80% of smallest internal corner radius"
        }

    return {
        "global_minimum_radius": None,
        "recommended_tool_radius": None,
        "design_guideline": "No internal corners detected; any tool radius acceptable"
    }
```

**`analyze_feature_accessibility(features, orientation) -> tuple[list, list]`**:
Analyze which features are reachable in a given orientation:
```python
def analyze_feature_accessibility(features, orientation):
    """
    Determine which features are reachable in given orientation.

    Args:
        features: List of feature dicts
        orientation: "Z_UP", "Y_UP", or "X_UP"

    Returns:
        (reachable_features, unreachable_features)
    """
    # Tool direction vectors for each orientation
    tool_directions = {
        "Z_UP": (0, 0, -1),  # Tool comes from +Z
        "Y_UP": (0, -1, 0),  # Tool comes from +Y
        "X_UP": (-1, 0, 0)   # Tool comes from +X
    }
    tool_dir = tool_directions.get(orientation, (0, 0, -1))

    reachable = []
    unreachable = []

    for feature in features:
        # Simple heuristic: assume features are reachable unless flagged
        # More sophisticated analysis would check face normals
        feature_copy = dict(feature)
        feature_copy["orientation"] = orientation

        # For now, mark all features as reachable
        # In future, could check face normals against tool direction
        reachable.append(feature_copy)

    return reachable, unreachable
```

Note: Keep accessibility analysis simple for now. The RESEARCH.md notes this is complex and should be conservative. Mark features as reachable unless clearly inaccessible.
  </action>
  <verify>
`python -m py_compile Fusion-360-MCP-Server/geometry_analysis/geometry_helpers.py`
  </verify>
  <done>
geometry_helpers.py exists with calculate_minimum_tool_radii (80% rule) and analyze_feature_accessibility functions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create orientation analyzer with setup sequences</name>
  <files>Fusion-360-MCP-Server/geometry_analysis/orientation_analyzer.py</files>
  <action>
Create `orientation_analyzer.py` with OrientationAnalyzer class:

**Class structure:**
```python
class OrientationAnalyzer:
    """
    Analyze part orientations for CAM planning.

    Suggests orientations ranked by minimal setups with setup/flip sequences.
    Per CONTEXT.md: primary optimization goal is minimize setups/flips.
    """

    # Scoring weights per RESEARCH.md recommendations
    WEIGHTS = {
        "feature_access": 0.60,  # % of features reachable
        "setup_count": 0.30,     # Fewer setups = higher score
        "stability": 0.10        # Base area relative to total
    }

    def __init__(self, features: list):
        self.features = features
```

**`suggest_orientations(body) -> list`**:
Per RESEARCH.md Pattern 5 and CONTEXT.md decisions:
```python
def suggest_orientations(self, body):
    """
    Suggest part orientations optimized for minimal setups.

    Returns:
        List of orientation dicts, ranked by score (best first)
    """
    from .geometry_helpers import analyze_feature_accessibility

    bbox = body.boundingBox
    orientations = []

    for axis in ["Z_UP", "Y_UP", "X_UP"]:
        # Calculate feature accessibility
        reachable, unreachable = analyze_feature_accessibility(
            self.features, axis
        )

        # Calculate base area for stability scoring
        base_area = self._calculate_base_area(bbox, axis)
        total_area = (
            (bbox.maxPoint.x - bbox.minPoint.x) *
            (bbox.maxPoint.y - bbox.minPoint.y) +
            (bbox.maxPoint.x - bbox.minPoint.x) *
            (bbox.maxPoint.z - bbox.minPoint.z) +
            (bbox.maxPoint.y - bbox.minPoint.y) *
            (bbox.maxPoint.z - bbox.minPoint.z)
        )

        # Estimate setup count (1 if all reachable, 2 if some unreachable)
        setup_count = 1 if not unreachable else 2

        # Calculate score using weights
        feature_ratio = len(reachable) / max(len(self.features), 1)
        setup_score = 1.0 / setup_count
        stability_score = base_area / max(total_area, 0.001)

        score = (
            feature_ratio * self.WEIGHTS["feature_access"] +
            setup_score * self.WEIGHTS["setup_count"] +
            stability_score * self.WEIGHTS["stability"]
        )

        # Build setup sequence
        sequence = self._build_setup_sequence(reachable, unreachable, axis)

        orientations.append({
            "axis": axis,
            "score": round(score, 2),
            "setup_count": setup_count,
            "reachable_features": len(reachable),
            "unreachable_features": len(unreachable),
            "unreachable_feature_list": [
                {
                    "type": f.get("type", "unknown"),
                    "reason": f.get("unreachable_reason", "Opposite face or undercut")
                }
                for f in unreachable
            ],
            "setup_sequence": sequence,
            "base_dimensions": self._get_base_dimensions(bbox, axis),
            "reasoning": f"{len(reachable)}/{len(self.features)} features reachable, {setup_count} setup(s) required"
        })

    # Sort by score (highest first)
    orientations.sort(key=lambda x: x["score"], reverse=True)
    return orientations
```

**Helper methods:**
- `_calculate_base_area(bbox, axis)`: Return area of face perpendicular to axis
- `_get_base_dimensions(bbox, axis)`: Return {"width": ..., "depth": ..., "height": ...} with units
- `_build_setup_sequence(reachable, unreachable, axis)`: Build step-by-step sequence:
  ```python
  def _build_setup_sequence(self, reachable, unreachable, axis):
      sequence = []

      if reachable:
          sequence.append({
              "step": 1,
              "action": "machine_top_features",
              "description": f"Machine {len(reachable)} accessible features from {axis} orientation",
              "feature_count": len(reachable)
          })

      if unreachable:
          sequence.append({
              "step": 2,
              "action": "flip_part",
              "description": "Flip part 180 degrees",
              "requires": "Manual flip or tombstone fixture"
          })
          sequence.append({
              "step": 3,
              "action": "machine_bottom_features",
              "description": f"Machine {len(unreachable)} features from opposite side",
              "feature_count": len(unreachable)
          })

      return sequence
  ```
  </action>
  <verify>
`python -m py_compile Fusion-360-MCP-Server/geometry_analysis/orientation_analyzer.py`
  </verify>
  <done>
orientation_analyzer.py exists with OrientationAnalyzer class that returns ranked orientations with setup_sequence, unreachable_feature_list, and scoring based on feature access/setup count/stability.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate orientation and radius analysis into cam_operations</name>
  <files>
    - Fusion-360-MCP-Server/geometry_analysis/__init__.py
    - Fusion-360-MCP-Server/cam_operations.py
  </files>
  <action>
1. **Update `__init__.py`** to export new modules:
   ```python
   from .feature_detector import FeatureDetector, DEFAULT_CONFIG
   from .orientation_analyzer import OrientationAnalyzer
   from .geometry_helpers import calculate_minimum_tool_radii, analyze_feature_accessibility
   ```

2. **Update `cam_operations.py`** imports (inside Fusion try/except):
   ```python
   try:
       from geometry_analysis import (
           FeatureDetector,
           OrientationAnalyzer,
           calculate_minimum_tool_radii
       )
       FEATURE_DETECTOR_AVAILABLE = True
   except ImportError:
       FEATURE_DETECTOR_AVAILABLE = False
   ```

3. **Enhance `handle_analyze_geometry_for_cam()`**:
   After feature detection, add:
   ```python
   # Orientation analysis with setup sequences
   if FEATURE_DETECTOR_AVAILABLE and all_recognized_features:
       analyzer = OrientationAnalyzer(all_recognized_features)
       body_result["suggested_orientations"] = analyzer.suggest_orientations(body)

   # Minimum tool radius calculation
   if FEATURE_DETECTOR_AVAILABLE:
       body_result["minimum_tool_radius"] = calculate_minimum_tool_radii(
           body, all_recognized_features
       )
   ```

4. **Replace existing basic orientation logic** (around lines 698-740) with the new OrientationAnalyzer output when available, keeping basic logic as fallback.

5. **Ensure output structure matches CONTEXT.md requirements:**
   - suggested_orientations: list with axis, score, setup_count, setup_sequence
   - minimum_tool_radius: global_minimum_radius, recommended_tool_radius, design_guideline
  </action>
  <verify>
`python -m py_compile Fusion-360-MCP-Server/cam_operations.py`
`grep -n "OrientationAnalyzer\|calculate_minimum_tool_radii\|setup_sequence" Fusion-360-MCP-Server/cam_operations.py`
  </verify>
  <done>
cam_operations.py uses OrientationAnalyzer for enhanced orientation suggestions with setup sequences, includes minimum_tool_radius with 80% rule calculation.
  </done>
</task>

</tasks>

<verification>
After all tasks:
1. All Python files in geometry_analysis/ pass syntax check
2. cam_operations.py passes syntax check
3. `grep -r "setup_sequence" Fusion-360-MCP-Server/` shows sequence planning
4. `grep -r "unreachable" Fusion-360-MCP-Server/geometry_analysis/` shows accessibility analysis
5. `grep -r "recommended_tool_radius" Fusion-360-MCP-Server/` shows 80% rule implementation
</verification>

<success_criteria>
- orientation_analyzer.py provides ranked orientations with setup_sequence
- Orientations scored by feature_access (60%), setup_count (30%), stability (10%)
- Unreachable features listed with reasons
- geometry_helpers.py provides calculate_minimum_tool_radii with 80% rule
- cam_operations.py integrates both modules
- Output includes suggested_orientations with sequences and minimum_tool_radius
- All Python files pass syntax validation
</success_criteria>

<output>
After completion, create `.planning/phases/02-geometry-analysis/02-03-SUMMARY.md`
</output>
