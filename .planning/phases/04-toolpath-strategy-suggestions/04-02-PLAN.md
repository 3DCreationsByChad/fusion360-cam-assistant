---
phase: 04-toolpath-strategy-suggestions
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - Fusion-360-MCP-Server/toolpath_strategy/strategy_preferences.py
  - Fusion-360-MCP-Server/toolpath_strategy/__init__.py
  - Fusion-360-MCP-Server/cam_operations.py
  - Fusion-360-MCP-Server/mcp_integration.py
autonomous: false

must_haves:
  truths:
    - "AI client can call suggest_toolpath_strategy via MCP and receive operation recommendations"
    - "Each feature gets a roughing and finishing recommendation with tool and feeds/speeds"
    - "Strategy preferences can be stored and retrieved per material + feature type"
    - "Response follows three-status pattern: success, preference_needed, no_features"
    - "tool_description in mcp_integration.py documents the operation so AI can discover it"
  artifacts:
    - path: "Fusion-360-MCP-Server/toolpath_strategy/strategy_preferences.py"
      provides: "SQLite strategy preference storage via MCP bridge"
      exports: ["get_strategy_preference", "save_strategy_preference", "initialize_strategy_schema", "STRATEGY_PREFERENCES_SCHEMA"]
    - path: "Fusion-360-MCP-Server/cam_operations.py"
      provides: "handle_suggest_toolpath_strategy function and route registration"
      contains: "handle_suggest_toolpath_strategy"
    - path: "Fusion-360-MCP-Server/mcp_integration.py"
      provides: "Updated tool_description with suggest_toolpath_strategy documentation"
      contains: "suggest_toolpath_strategy"
  key_links:
    - from: "Fusion-360-MCP-Server/cam_operations.py"
      to: "Fusion-360-MCP-Server/toolpath_strategy/"
      via: "import from .toolpath_strategy"
      pattern: "from \\.toolpath_strategy import"
    - from: "Fusion-360-MCP-Server/cam_operations.py"
      to: "route_cam_operation handlers dict"
      via: "handlers['suggest_toolpath_strategy'] = handle_suggest_toolpath_strategy"
      pattern: "suggest_toolpath_strategy.*handle_suggest_toolpath_strategy"
    - from: "Fusion-360-MCP-Server/mcp_integration.py"
      to: "tool_description string"
      via: "suggest_toolpath_strategy documentation block"
      pattern: "suggest_toolpath_strategy.*Get Strategy"
---

<objective>
Wire the toolpath strategy module into the MCP system: create strategy preference storage, build the main handler function in cam_operations.py, update the MCP tool description for AI discoverability, and verify end-to-end in Fusion 360.

Purpose: This plan completes Phase 4 by connecting the rules engine (Plan 01) to the MCP protocol. After this, an AI client can call suggest_toolpath_strategy with a body name and material, and receive per-feature operation recommendations with tools and cutting parameters.

Output: Working suggest_toolpath_strategy MCP operation, strategy preferences SQLite table, updated tool_description, verified in Fusion 360.
</objective>

<execution_context>
@C:\Users\cdeit\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cdeit\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-toolpath-strategy-suggestions/04-RESEARCH.md
@.planning/phases/04-toolpath-strategy-suggestions/04-01-SUMMARY.md

Key files to reference for patterns:
@Fusion-360-MCP-Server/cam_operations.py (handle_suggest_stock_setup is the pattern for this handler)
@Fusion-360-MCP-Server/mcp_integration.py (tool_description variable and routing in _fusion_tool_handler_impl)
@Fusion-360-MCP-Server/stock_suggestions/preference_store.py (SQLite preference pattern)
@Fusion-360-MCP-Server/stock_suggestions/__init__.py (module export pattern)

Established patterns from Phase 3 that MUST be followed:
1. Three-response-status pattern: "success", "preference_needed", and a third status
2. Source attribution: "from: default_rules" or "from: user_preference"
3. MCP SQLite bridge: tool_unlock_token "29e63eb5" for all sqlite calls
4. Relative imports: from .toolpath_strategy import ...
5. Graceful import fallback: TOOLPATH_STRATEGY_AVAILABLE flag
6. tool_description documentation: Full JSON example with arguments and return shape
7. Features processed in priority order: drilling -> roughing -> finishing
8. Explicit unit format on all dimensional values

Key integration points:
- cam_operations.py line ~43-56: Add import block for toolpath_strategy (follow stock_suggestions pattern)
- cam_operations.py line ~1336-1358: Add to route_cam_operation handlers dict (uncomment the commented line)
- mcp_integration.py line ~351: Replace "coming soon" with full documentation
- mcp_integration.py line ~483: Already routes suggest_toolpath_strategy to cam_operations
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create strategy preferences and MCP handler</name>
  <files>
    Fusion-360-MCP-Server/toolpath_strategy/strategy_preferences.py
    Fusion-360-MCP-Server/toolpath_strategy/__init__.py
    Fusion-360-MCP-Server/cam_operations.py
    Fusion-360-MCP-Server/mcp_integration.py
  </files>
  <action>
Create strategy_preferences.py and wire everything together:

**strategy_preferences.py** (~100 lines):
Follow the exact pattern from stock_suggestions/preference_store.py:

- `STRATEGY_PREFERENCES_SCHEMA`: CREATE TABLE IF NOT EXISTS cam_strategy_preferences with columns:
  - id INTEGER PRIMARY KEY AUTOINCREMENT
  - material TEXT NOT NULL
  - feature_type TEXT NOT NULL (e.g., "hole", "pocket", "slot")
  - preferred_roughing_op TEXT (e.g., "adaptive_clearing", "2d_pocket")
  - preferred_finishing_op TEXT (e.g., "2d_contour")
  - preferred_tool_diameter_mm REAL
  - confidence_score REAL DEFAULT 0.5
  - times_used INTEGER DEFAULT 1
  - created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
  - updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
  - UNIQUE(material, feature_type)

- `SQLITE_TOOL_UNLOCK_TOKEN = "29e63eb5"` (same as stock_suggestions)

- `initialize_strategy_schema(mcp_call_func: Callable) -> bool`:
  Execute CREATE TABLE via mcp_call_func. Same pattern as stock_suggestions/preference_store.py.

- `get_strategy_preference(material: str, feature_type: str, mcp_call_func: Callable) -> Optional[Dict]`:
  - Normalize: material.lower().strip(), feature_type.lower().strip()
  - SELECT from cam_strategy_preferences WHERE material = ? AND feature_type = ?
  - Return dict with: preferred_roughing_op, preferred_finishing_op, preferred_tool_diameter_mm, confidence_score, source: "from: user_preference"
  - Return None if not found

- `save_strategy_preference(material: str, feature_type: str, preference_dict: Dict, mcp_call_func: Callable) -> bool`:
  - INSERT OR REPLACE into cam_strategy_preferences
  - Increment times_used on update
  - Normalize keys to lowercase

**Update toolpath_strategy/__init__.py**:
Add exports from strategy_preferences module to __init__.py and __all__:
```python
from .strategy_preferences import (
    get_strategy_preference,
    save_strategy_preference,
    initialize_strategy_schema,
    STRATEGY_PREFERENCES_SCHEMA
)
```

**Update cam_operations.py**:

1. Add import block after the stock_suggestions import (~line 56):
```python
# Toolpath strategy module for operation mapping, tool selection,
# feeds/speeds calculation, and strategy preference storage
try:
    from .toolpath_strategy import (
        get_material_properties,
        calculate_feeds_speeds,
        select_best_tool,
        map_feature_to_operations,
        get_strategy_preference,
        save_strategy_preference,
        initialize_strategy_schema
    )
    TOOLPATH_STRATEGY_AVAILABLE = True
except ImportError:
    TOOLPATH_STRATEGY_AVAILABLE = False
```

2. Create `handle_suggest_toolpath_strategy(arguments: dict) -> dict` function.
Follow handle_suggest_stock_setup as the structural template. The handler:

Arguments accepted:
- body_name (str, optional): Specific body to analyze (default: first body)
- material (str, optional): Material name for SFM lookup (default: from body or "aluminum")
- use_defaults (bool): Skip preference check, use default rules (default: False)
- save_as_preference (bool): Save results as new preferences (default: False)
- is_carbide (bool): Whether tools are carbide (default: True)

Handler flow:
a. Check TOOLPATH_STRATEGY_AVAILABLE and FUSION_AVAILABLE
b. Get body (same pattern as suggest_stock_setup)
c. Get material from arguments or body.material (default: "aluminum")
d. Run analyze_geometry_for_cam to get recognized_features and features_by_priority
e. If no recognized features, return `{"status": "no_features", "message": "No machinable features detected..."}`
f. Get tool library via handle_get_tool_library (call directly, parse result)
g. If mcp_call_func available and not use_defaults, check strategy preferences
h. For each feature in features_by_priority order:
   - Call map_feature_to_operations(feature, material)
   - Check preference override: if preference exists for this material+feature_type, use it
   - Call select_best_tool(feature, tools, tool_type_filter) where filter is "drill" for drilling ops, None otherwise
   - Call calculate_feeds_speeds(material, selected_tool, is_carbide, operation_type)
   - Build suggestion dict per feature
i. If save_as_preference and mcp_call_func, save each feature type preference
j. Return success response:
```python
{
    "status": "success",
    "material": material,
    "is_carbide": is_carbide,
    "feature_count": len(all_features),
    "suggestions": [
        {
            "feature": {
                "type": "pocket",
                "id": feature.get("id"),
                "dimensions": {
                    "depth": feature.get("depth"),
                    "width": feature.get("width"),
                    "length": feature.get("length")
                }
            },
            "roughing": {
                "operation_type": "adaptive_clearing",
                "confidence": 0.9,
                "reasoning": "Deep pocket (15mm) in medium material"
            },
            "finishing": {
                "operation_type": "2d_contour",
                "confidence": 0.85,
                "reasoning": "Standard contour finishing"
            },
            "recommended_tool": {
                "description": "6mm 4-flute carbide endmill",
                "diameter": {"value": 6.0, "unit": "mm"},
                "reasoning": "Largest tool fitting 8mm corner radius (80% rule)"
            },
            "cutting_parameters": {
                "rpm": {"value": 12000, "unit": "rpm"},
                "feed_rate": {"value": 1500, "unit": "mm/min"},
                "stepover_roughing": {"value": 2.7, "unit": "mm"},
                "stepover_finishing": {"value": 0.9, "unit": "mm"},
                "stepdown_roughing": {"value": 6.0, "unit": "mm"}
            }
        }
    ],
    "processing_order": "drilling -> roughing -> finishing",
    "source": "from: default_rules",  # or "from: user_preference" if preferences used
    "note": "These are starting-point suggestions. Adjust based on machine rigidity, workholding, and tool condition."
}
```

k. Handle errors gracefully: if tool selection fails for a feature, include the feature with `"status": "no_tool_available"` and continue to next feature

3. Register in route_cam_operation (replace the commented-out line ~1348):
```python
'suggest_toolpath_strategy': handle_suggest_toolpath_strategy,
```

**Update mcp_integration.py**:

Replace the "coming soon" line for suggest_toolpath_strategy (~line 351) with full documentation:
```
### suggest_toolpath_strategy - Get Strategy Recommendations
{
  "operation": "suggest_toolpath_strategy",
  "body_name": "Part1",
  "material": "Aluminum",
  "is_carbide": true,
  "use_defaults": false,
  "save_as_preference": false
}
All arguments are optional. Returns per-feature operation recommendations:
- "success": Suggestions with roughing/finishing operations, tool selection, and feeds/speeds per feature
- "no_features": No machinable features detected in the part
Each suggestion includes recommended_tool, cutting_parameters (RPM, feed rate, stepover, stepdown), and confidence scores.
```

Also keep the "coming soon" for record_user_choice and suggest_post_processor (those are Phase 5/6).
  </action>
  <verify>
- Python syntax check on strategy_preferences.py
- Verify cam_operations.py has handle_suggest_toolpath_strategy function
- Verify cam_operations.py route_cam_operation dict includes 'suggest_toolpath_strategy'
- Verify mcp_integration.py tool_description no longer says "coming soon" for suggest_toolpath_strategy
- Verify cam_operations.py imports from .toolpath_strategy with try/except pattern
- Search for "suggest_toolpath_strategy" in both cam_operations.py and mcp_integration.py
  </verify>
  <done>
strategy_preferences.py provides cam_strategy_preferences SQLite table with get/save functions.
handle_suggest_toolpath_strategy wired into cam_operations.py and route_cam_operation.
mcp_integration.py tool_description documents the operation for AI discoverability.
Operation returns per-feature suggestions with roughing/finishing ops, tools, and feeds/speeds.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete suggest_toolpath_strategy MCP operation that:
- Analyzes part features (holes, pockets, slots) and recommends CAM operations
- Selects appropriate tools from the document library
- Calculates feeds/speeds based on material properties
- Returns structured recommendations per feature with confidence scores
  </what-built>
  <how-to-verify>
1. Open Fusion 360 with the MCP-Link add-in active
2. Open a design with known features (holes, pockets) and a CAM setup with tools in the document library
3. Restart the add-in (Tools > Add-Ins > Stop/Run MCP-Link) to reload the updated code
4. Via your AI client, call:
   ```json
   {
     "operation": "suggest_toolpath_strategy",
     "material": "Aluminum",
     "use_defaults": true
   }
   ```
5. Verify the response contains:
   - "status": "success"
   - "suggestions" array with entries per detected feature
   - Each suggestion has roughing/finishing operation types
   - Each suggestion has a recommended_tool with diameter
   - Each suggestion has cutting_parameters with RPM and feed_rate
   - Values are reasonable for aluminum (RPM should be high, e.g. 8000-20000 for small endmills)
6. If the part has no CAM-detectable features, verify you get "status": "no_features"
7. Try with a different material (e.g., "Steel") and verify RPM values are lower
  </how-to-verify>
  <resume-signal>Type "approved" if suggestions look reasonable, or describe any issues</resume-signal>
</task>

</tasks>

<verification>
1. strategy_preferences.py follows stock_suggestions/preference_store.py pattern exactly
2. cam_operations.py has TOOLPATH_STRATEGY_AVAILABLE import flag
3. handle_suggest_toolpath_strategy processes features in priority order
4. MCP tool_description documents suggest_toolpath_strategy (not "coming soon")
5. Route registered in handlers dict
6. Three response statuses: success, preference_needed (when no prefs), no_features
7. All dimensional outputs use {"value": X, "unit": "mm"} format
8. Source attribution present in all responses
9. Confidence + reasoning on every recommendation
10. Error handling: features with no fitting tool get status "no_tool_available" but don't crash the whole response
</verification>

<success_criteria>
- suggest_toolpath_strategy callable via MCP protocol
- Response includes per-feature operation recommendations with tools and feeds/speeds
- AI client can discover the operation via tool_description
- Strategy preferences storable in SQLite (cam_strategy_preferences table)
- Human verification in Fusion 360 confirms reasonable suggestions
- Handles edge cases: no features, no fitting tools, unknown materials
</success_criteria>

<output>
After completion, create `.planning/phases/04-toolpath-strategy-suggestions/04-02-SUMMARY.md`
</output>
