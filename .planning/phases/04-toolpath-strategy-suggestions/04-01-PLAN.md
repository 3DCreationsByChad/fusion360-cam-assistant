---
phase: 04-toolpath-strategy-suggestions
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Fusion-360-MCP-Server/toolpath_strategy/__init__.py
  - Fusion-360-MCP-Server/toolpath_strategy/material_library.py
  - Fusion-360-MCP-Server/toolpath_strategy/feeds_speeds.py
  - Fusion-360-MCP-Server/toolpath_strategy/tool_selector.py
  - Fusion-360-MCP-Server/toolpath_strategy/operation_mapper.py
autonomous: true

must_haves:
  truths:
    - "Feature types (hole, pocket, slot) map to correct CAM operation types"
    - "Feeds/speeds are calculated from material SFM values and tool geometry"
    - "Largest tool that fits is selected with 80% corner radius rule"
    - "Unknown materials receive conservative default values"
    - "Material lookup is case-insensitive with partial matching"
  artifacts:
    - path: "Fusion-360-MCP-Server/toolpath_strategy/__init__.py"
      provides: "Module exports for all toolpath strategy components"
      contains: "from .material_library import"
    - path: "Fusion-360-MCP-Server/toolpath_strategy/material_library.py"
      provides: "Material SFM/chip-load database with lookup"
      exports: ["MATERIAL_LIBRARY", "get_material_properties"]
    - path: "Fusion-360-MCP-Server/toolpath_strategy/feeds_speeds.py"
      provides: "RPM and feed rate calculation from material + tool"
      exports: ["calculate_feeds_speeds"]
    - path: "Fusion-360-MCP-Server/toolpath_strategy/tool_selector.py"
      provides: "Tool selection logic with 80% corner radius rule"
      exports: ["select_best_tool"]
    - path: "Fusion-360-MCP-Server/toolpath_strategy/operation_mapper.py"
      provides: "Feature-to-operation mapping with condition evaluation"
      exports: ["map_feature_to_operations", "OPERATION_RULES"]
  key_links:
    - from: "Fusion-360-MCP-Server/toolpath_strategy/feeds_speeds.py"
      to: "Fusion-360-MCP-Server/toolpath_strategy/material_library.py"
      via: "import get_material_properties"
      pattern: "from \\.material_library import"
    - from: "Fusion-360-MCP-Server/toolpath_strategy/operation_mapper.py"
      to: "Fusion-360-MCP-Server/toolpath_strategy/material_library.py"
      via: "material hardness lookup for depth threshold"
      pattern: "get_material_properties"
---

<objective>
Create the toolpath strategy rules engine as a self-contained Python module with four components: material property database, feeds/speeds calculator, tool selector, and feature-to-operation mapper.

Purpose: This is the core intelligence of Phase 4. These pure-Python modules encode CNC machining heuristics that map detected features to recommended CAM operations with calculated cutting parameters. No Fusion API dependency -- these are testable calculation modules.

Output: `toolpath_strategy/` module with material_library.py, feeds_speeds.py, tool_selector.py, operation_mapper.py, and __init__.py.
</objective>

<execution_context>
@C:\Users\cdeit\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\cdeit\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-toolpath-strategy-suggestions/04-RESEARCH.md

Key existing patterns to follow:
- Relative imports: `from .material_library import ...` (required for Fusion add-in package loading)
- Explicit units: `{"value": X, "unit": "mm"}` on all dimensional outputs
- Confidence + reasoning: Every recommendation includes confidence score (0-1) and reasoning string
- Source attribution: `"source": "from: default_rules"` or `"from: user_preference"`
- Lowercase normalization: All lookup keys normalized to lowercase with underscores
- Graceful defaults: Unknown inputs get conservative fallback values, never raise errors

Existing decisions that constrain this plan:
- 80% rule for tool radius (Phase 2 decision): tool_radius <= 0.8 * corner_radius
- Depth threshold 10mm (Phase 2 decision): adaptive clearing > 10mm, 2D pocket <= 10mm
- Drilling < 12mm diameter (Phase 2 decision): holes under 12mm use drilling
- Slot threshold aspect_ratio > 3.0 (Phase 2 decision)
- Flute length constraint: flute_length >= depth * 1.2 (20% safety margin, from research)
- Stepover: 40-50% roughing, 10-20% finishing (from research)
- Stepdown: 0.5-1.5x tool diameter for roughing (from research)
- SFM formula: RPM = (SFM * 3.82) / diameter_inches (from research)
- Feed formula: feed_rate = RPM * flutes * chip_load (from research)
- Carbide multiplier: 3x HSS SFM values (from research)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create material library and feeds/speeds calculator</name>
  <files>
    Fusion-360-MCP-Server/toolpath_strategy/__init__.py
    Fusion-360-MCP-Server/toolpath_strategy/material_library.py
    Fusion-360-MCP-Server/toolpath_strategy/feeds_speeds.py
  </files>
  <action>
Create the `Fusion-360-MCP-Server/toolpath_strategy/` directory and these three files:

**material_library.py** (~80 lines):
- `MATERIAL_LIBRARY` dict with entries for: aluminum, mild_steel, stainless_steel, brass, plastic, wood
- Each entry contains: `sfm_hss` (int), `sfm_carbide` (int), `chip_load_range` (tuple of floats in inches/tooth), `hardness` (str: "soft"/"medium"/"hard")
- Values from research: aluminum (400/1200), mild_steel (100/300), stainless_steel (40/120), brass (300/900), plastic (500/1500), wood (600/1800)
- `get_material_properties(material_name: str) -> dict` function:
  - Normalize input: `material_name.lower().replace(" ", "_").replace("-", "_")`
  - Try exact match first
  - Try partial match (e.g., "6061 aluminum" matches "aluminum", "304 stainless" matches "stainless_steel")
  - Fallback to conservative defaults: `{"sfm_hss": 100, "sfm_carbide": 300, "chip_load_range": (0.0005, 0.001), "hardness": "medium"}`
  - Always include `"source": "from: material_library"` or `"source": "from: default_conservative"` in return

**feeds_speeds.py** (~70 lines):
- `calculate_feeds_speeds(material: str, tool: dict, is_carbide: bool = True, operation_type: str = "roughing") -> dict`
  - `tool` dict has keys: `diameter` (dict with value/unit), `flutes` (int), optionally `flute_length`
  - Get material properties via `from .material_library import get_material_properties`
  - SFM: Use sfm_carbide if is_carbide else sfm_hss
  - diameter_mm from tool["diameter"]["value"], convert to inches: diameter_mm / 25.4
  - RPM = (SFM * 3.82) / diameter_inches -- cap at 24000 (typical spindle max)
  - chip_load: Use midpoint of chip_load_range for roughing, low end * 0.7 for finishing
  - feed_rate_ipm = RPM * flutes * chip_load
  - feed_rate_mmpm = feed_rate_ipm * 25.4
  - stepover_roughing = diameter_mm * 0.45 (midpoint of 40-50%)
  - stepover_finishing = diameter_mm * 0.15 (midpoint of 10-20%)
  - stepdown_roughing = diameter_mm * 1.0 (midpoint of 0.5-1.5x)
  - Return dict with all values in explicit unit format: `{"rpm": {"value": round(rpm), "unit": "rpm"}, "feed_rate": {"value": round(feed_mmpm), "unit": "mm/min"}, ...}`
  - Include `"calculation_basis"` string and `"is_carbide"` bool in return

**__init__.py** (~30 lines):
- Import and re-export all public functions from all four submodules
- Docstring describing the module purpose
- `__all__` list with all exports

NOTE: __init__.py will initially reference tool_selector and operation_mapper which don't exist yet. Use try/except import pattern with AVAILABLE flags (established pattern from cam_operations.py):
```python
try:
    from .tool_selector import select_best_tool
    TOOL_SELECTOR_AVAILABLE = True
except ImportError:
    TOOL_SELECTOR_AVAILABLE = False
```
This allows Task 1 to complete independently while Task 2 adds the remaining modules.
  </action>
  <verify>
Verify the files exist and have correct structure:
- `ls Fusion-360-MCP-Server/toolpath_strategy/` shows __init__.py, material_library.py, feeds_speeds.py
- Python syntax check: `python -c "import ast; ast.parse(open('Fusion-360-MCP-Server/toolpath_strategy/material_library.py').read())"` (repeat for feeds_speeds.py)
- Verify material_library has at least 6 materials in MATERIAL_LIBRARY dict
- Verify feeds_speeds.py imports from .material_library
- Verify explicit unit format in feeds_speeds return type annotations/docstring
  </verify>
  <done>
material_library.py has 6+ materials with SFM/chip_load data and get_material_properties() with partial matching.
feeds_speeds.py calculates RPM/feed/stepover/stepdown with explicit unit format outputs.
__init__.py exports all public functions with graceful import fallback for not-yet-created modules.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create tool selector and operation mapper</name>
  <files>
    Fusion-360-MCP-Server/toolpath_strategy/tool_selector.py
    Fusion-360-MCP-Server/toolpath_strategy/operation_mapper.py
    Fusion-360-MCP-Server/toolpath_strategy/__init__.py
  </files>
  <action>
Create two more modules and update __init__.py to remove the try/except fallbacks:

**tool_selector.py** (~80 lines):
- `select_best_tool(feature: dict, available_tools: list, tool_type_filter: str = None) -> dict`
  - Extract min_corner_radius from feature: `feature.get("min_corner_radius", {}).get("value", float('inf'))`
  - Also check `feature.get("min_internal_radius_mm")` as fallback (Phase 2 format)
  - Apply 80% rule: `max_tool_radius = min_radius * 0.8`
  - Filter tools by type if tool_type_filter provided (match against tool["type"].lower())
  - Filter tools where `tool["diameter"]["value"] / 2 <= max_tool_radius`
  - For operations with depth, also filter by flute length: `tool.get("flute_length", {}).get("value", float('inf')) >= feature_depth * 1.2` (20% safety)
  - Select largest fitting tool: `max(fitting_tools, key=lambda t: t["diameter"]["value"])`
  - If no tools fit, return `{"status": "no_tool_available", "reason": "...", "constraint": {"max_radius_mm": max_tool_radius}}`
  - On success return: `{"status": "ok", "tool": selected_tool, "reasoning": "...", "stepover_roughing": {"value": ..., "unit": "mm"}, "stepover_finishing": {"value": ..., "unit": "mm"}}`

**operation_mapper.py** (~100 lines):
- `OPERATION_RULES` dict mapping feature types to operation recommendations:
  - "hole": conditions based on diameter < 12mm -> "drilling", diameter >= 12mm -> "helical_milling" or "boring"
  - "pocket": conditions based on depth > 10mm AND hardness != "soft" -> "adaptive_clearing", else "2d_pocket"
  - "slot": width <= recommended_tool_diameter -> "slot_milling", width > tool_diameter -> "adaptive_clearing"
  - Default fallback for unknown types: "2d_contour" with confidence 0.5
- `map_feature_to_operations(feature: dict, material: str) -> dict`
  - Look up feature type in OPERATION_RULES
  - Evaluate conditions using feature dimensions and material hardness (via get_material_properties)
  - For each feature, return BOTH roughing and finishing recommendations:
    - roughing_operation: the primary material removal strategy
    - finishing_operation: "2d_contour" for most features, "drilling" for holes (no separate finish)
  - Include confidence (0.0-1.0) and reasoning string per recommendation
  - Process features in priority order: drilling (priority 1) -> roughing (priority 2) -> finishing (priority 3)
  - Import: `from .material_library import get_material_properties`
  - Return format:
    ```python
    {
        "feature_type": "pocket",
        "roughing": {
            "operation_type": "adaptive_clearing",
            "confidence": 0.9,
            "reasoning": "Deep pocket (15mm) in medium-hardness material"
        },
        "finishing": {
            "operation_type": "2d_contour",
            "confidence": 0.85,
            "reasoning": "Standard contour finishing for pocket walls"
        },
        "source": "from: default_rules"
    }
    ```

**Update __init__.py**:
- Remove the try/except fallback pattern for tool_selector and operation_mapper
- Add direct imports now that all modules exist
- Update __all__ to include all exports: MATERIAL_LIBRARY, get_material_properties, calculate_feeds_speeds, select_best_tool, map_feature_to_operations, OPERATION_RULES
  </action>
  <verify>
- `ls Fusion-360-MCP-Server/toolpath_strategy/` shows all 5 files
- Python syntax check on tool_selector.py and operation_mapper.py
- Verify operation_mapper.py contains rules for "hole", "pocket", and "slot"
- Verify tool_selector.py implements 80% rule (search for "0.8" in file)
- Verify tool_selector.py checks flute_length constraint (search for "1.2" in file)
- Verify __init__.py has clean imports (no try/except fallback) and complete __all__
  </verify>
  <done>
tool_selector.py selects largest fitting tool with 80% corner radius rule and flute length constraint.
operation_mapper.py maps holes/pockets/slots to roughing+finishing operations with confidence/reasoning.
__init__.py cleanly exports all public APIs from all four submodules.
Complete toolpath_strategy module is ready for integration in Plan 02.
  </done>
</task>

</tasks>

<verification>
1. All 5 files exist in Fusion-360-MCP-Server/toolpath_strategy/
2. Python syntax is valid for all files
3. material_library has 6+ materials with SFM values matching research values
4. feeds_speeds uses correct formulas: RPM = (SFM * 3.82) / diameter_inches
5. tool_selector applies 80% rule and flute length >= depth * 1.2
6. operation_mapper has rules for hole (12mm threshold), pocket (10mm depth threshold), slot
7. All outputs use explicit unit format {"value": X, "unit": "mm"}
8. All recommendations include confidence + reasoning
9. Relative imports used throughout (from .module import ...)
10. Lowercase normalization on all lookup keys
</verification>

<success_criteria>
- toolpath_strategy/ module exists with 5 Python files
- material_library covers aluminum, mild_steel, stainless_steel, brass, plastic, wood
- feeds_speeds calculates RPM, feed rate, stepover, stepdown with explicit units
- tool_selector returns best fitting tool with 80% rule enforcement
- operation_mapper returns roughing + finishing recommendations per feature
- All functions handle edge cases (unknown material, no fitting tools, missing data)
- Module is self-contained -- no Fusion API imports needed
</success_criteria>

<output>
After completion, create `.planning/phases/04-toolpath-strategy-suggestions/04-01-SUMMARY.md`
</output>
